---
title: its-ctl
keywords: gal composite
tags: [gal]
sidebar: home_sidebar
permalink: ctl.html
summary: A model-checker for CTL properties built using libITS.
---

# its-ctl 

## What is its-ctl

its-ctl is our model-checker for [Computation Tree Logic](https://en.wikipedia.org/wiki/Computation_tree_logic) properties, built upon [libITS](libits.md).
It offers support for efficient symbolic CTL model checking using saturation and forward transition relation among other features.

its-ctl is a library and tool for CTL model-checking of Instantiable Transition Systems. It leverages on the ITS and SDD libraries and on a component for CTL formula manipulation taken from [VIS](http://vlsi.colorado.edu/~vis/).

its-ctl is stable, it has been used notably in the [project Neoppod](https://projets-systeme.lip6.fr/trac/research/NEOPPOD/wiki/pnxdd). It currently supports the following features:

*   ITS model input: any ITS model can be CTL checked.
*   Forward model-checking using the past temporal logic operators. This feature is activated by default as it provides superior performance in practically all cases.
*   Full witness/counter-example trace explanation.


## Obtaining its-ctl

You can download the current release as well as binaries from here: [LibITS download page](https://lip6.github.io/ITS-CTL/)

The latest source version of its-ctl can be obtained from GitHub at _https://github.com/lip6/ITS-CTL_. 

Note that to build from the git, you need autotools and to invoke "autoreconf -vfi" to create the "configure" script. 
Due to various dependencies, building from git requires some configuration settings. 

Remember, configure --help is your friend, and you can also have a look at the configuration settings of 
our [Travis continuous integration server](https://github.com/lip6/ITS-CTL/blob/master/.travis.yml) 
or [AppVeyor for Windows](https://github.com/lip6/ITS-CTL/blob/master/appveyor.yml) for inspiration on how to invoke configure.

The only dependencies are libDDD and libITS that you need to deploy first.

## Usage

If you just intend to use the tool at a command-line, run it with option "-h" to get a description of various options available. 

The Samples/ folder contains many examples, and the tests/ folder cover many common invocation idioms. 
Note that the command-line tool is meant for experts or back-end model-checking, and it is usually invoked through scripts on verified input or as generated by other tools.

If you want to experiment using the command line tool on models edited with ITS modeler front-end, just run any analysis on your model, a side effect is to generate input 
compatible with the command line tool in the current "work" folder. 

See [this page](https://github.com/lip6/ITS-CTL/blob/master/tests/tests.def) for invocation examples.

You can also use the [eclipse front-end](running.md) to produce valid command line invocations of its-ctl.


### Checking CTL properties

To verify CTL properties use flag "-ctl CTLFILE" and pass a file containing CTL formulas.
See the "tests/" folder for examples of legal CTL files.

If witness are activated, a witness trace will be produced :
* A witness is a composed of parts, corresponding to the syntactic tree of the input formula
* Some witnesses are sequential traces (*EF* operator), some are one possible loop in an SCC (*EG* operator)
* all traces reported are shortest paths, use **--backward --trace-states** for more readable traces
* When boolean connectors are encountered, the counter example is further explained   	

The semantics are not quite text-book; in presence of deadlocks, **EG p** will stutter and accept dead states satisfying **p**.
This does not affect the semantics of **EX, AX**, so that **AG (EX (true))** does test for absence of deadlocks.
For a more formal presentation of this semantics see this document [Aalborg University, TAPAAL team's CTL semantics document](files/CTL-semantics.pdf), used in the [MCC](http://mcc.lip6.fr).
These semantics are more natural for reasoning.

### Checking Deadlock and Timelock

Use "-ctl DEADLOCK" to check for deadlocks, i.e. states in which no transition can fire.
The results are roughly equivalent to checking "AG(EX(true))".

Use "-ctl TIMELOCK" to check for __timelocks__, i.e. states in which no transition can fire except time elapse.
In timed systems, these are often more interesting than full deadlocks, that should not occur
in well formed times transition systems anyway. It is not useful to activate "--fair-time" in
 conjunction with this option.

### Fair time

Use this option "--fair-time" to enforce fair time elapse transition.

Note that the formula is first translated to pure existential form, and also rewritten to perform forward
CTL when possible. To help interpretation of witness traces, activating the "backward" option removes some
 of these transformations, making the trace usually more readable. 

The fair-time setting is only useful if your model features discrete time, as indicated by a top level
label in the *main* instance called "elapse". Models obtained from [time Petri nets](tpn.md), or from
[timed automata](ta.md) have this feature. In those cases however, you usually do want to activate it,
it prevents witness traces that are abusing divergence on the time step and thus gives results
 similar to e.g. Romeo.
 
## Acknowledgement

The code base for ITS-CTL is heavily based on the ctlp and mc components of VIS from Boulder University. See VIS: A system for Verification and Synthesis, [VIS homepage](http://vlsi.colorado.edu/~vis/). 

The ctlp package is due to Gary York, Ramin Hojati, Tom Shiple, Adnan Aziz, Yuji Kukimoto, Jae-Young Jang, In-Ho Moon. The mc package is due to Adnan Aziz, Tom Shiple, In-Ho Moon.  

The code was reworked to remove the dependency on GLU/CUDD the decision diagram package they use (and have developped). 
The SDD/ITS code for CTL checking is due to Yann Thierry-Mieg, and Silien Hong.

The witness/counter-example code was written by Yann Thierry-Mieg.
 
For further credits and version history please browse the repository history.
